from Modules.CloudCompute.utils.util_helpers import *

#TODO allow project ids without requiring prompt

def run_module(user_args, session, first_run = False, last_run = False, output_format = ["table"]):

    # Set up Argparser to handle flag arguments
    parser = argparse.ArgumentParser(description="Module to Upload SSH Keys", allow_abbrev=False)

    parser.add_argument("--instance-name",type=str,required=False,help="Instance to target in form /projects/*/zones/*/instances/*")
    
    parser.add_argument("--username", type=str, help="Username of SSH key generated (aka what you set at cmdline)")
    ssh_input_option = parser.add_mutually_exclusive_group(required = False)
    ssh_input_option.add_argument("--ssh-key", type=str, help="SSH Key supplied in stdin")
    ssh_input_option.add_argument("--ssh-key-file", type=str,  help="SSH key supplied in file (ex. /home/kali/.ssh/id_rsa.pub)")

    # Specify if metadata update is happening at project or at the instance level
    instance_or_project = parser.add_mutually_exclusive_group()
    instance_or_project.add_argument("--instance-level",action="store_true",required=False,help="Set SSH key at instance level")
    instance_or_project.add_argument("--project-level",action="store_true",required=False,help="Set SSH key at project level")
    
    parser.add_argument("--brute",action="store_true",required=False,help=f"{UtilityTools.RED}{UtilityTools.BOLD}WARNING: Overwrite ALL previous metadata{UtilityTools.RESET}")

    parser.add_argument("-v","--debug",action="store_true",required=False,help="Get verbose data returned")

    args = parser.parse_args(user_args)

    action_dict, project_id = {}, session.project_id

    debug = args.debug

    project_id, instance_zone, instance_name, ssh_keys, username = None, None, None, None, None
    
    change_instance, change_project = False, False

    # Handle user supplied arguments
    # Make sure function name adheres to regex
    if args.instance_name:
        change_instance = True
        instance_full_name = args.instance_name
        status, incorrect_input = UtilityTools.validate_input_format(instance_full_name, 6)
        if status != 0: 
            print(f"{UtilityTools.RED}[X] Value \"{incorrect_input}\" is incorrect. Must be 'projects/[project_id]/zones/[zone]/instance/[instance_name] Please try again...{UtilityTools.RESET}")
            return -1

        _, project_id, _, instance_zone, _, instance_name = instance_full_name.split("/")

    if args.username:
        username = args.username

    if args.ssh_key:
        ssh_keys = [args.ssh_key]

    elif args.ssh_key_file:

        ssh_keys = [line.strip() for line in open(args.ssh_key_file).readlines()]

    if args.instance_level:
        change_instance = True

    elif args.project_level:
        change_project = True

    # Handle arguments user did not supply, query intenral db

    if not change_instance and not change_project:
        selection = session.choice_selector(["Project","Instance"],"Do you want to try editing the project itself (enable ssh login on potentially ALL instances) or a specific instance?")

        if selection == "Instance":
            change_instance = True

        elif selection == "Project":
            change_project = True
    
    if not instance_name and change_instance:
        rows_returned = session.get_data("cloudcompute-instances", ["name","status","zone","project_id"])
        
        if len(rows_returned) == 0:
            print("[X] Exiting since there are no instances provided or found. Consider passing in instance name with --instance-name if you have it in mind.")
            return -1

        for instance in rows_returned:
            local_instance_name = instance["name"]
            local_instance_status = instance["status"]
            local_instance_zone = instance["zone"].split("/")[-1]
            local_instance_project_id = instance["project_id"]

            instance["printout"] = f"[{local_instance_project_id}] {local_instance_name} (@ {local_instance_zone}) - STATUS: {local_instance_status}"

        rows_returned = sorted(rows_returned, key=lambda x: x["zone"])

        function_dict = session.choice_selector(rows_returned,"Choose an existing instance from below to add SSH keys to:", fields=["printout"])
        
        instance_name = function_dict["name"]
        instance_zone = function_dict["zone"].split("/")[-1]
        project_id = function_dict["project_id"]


    if change_project:
        rows_returned = session.get_data("abstract-tree-hierarchy", ["name","display_name","project_id"])
        
        if len(rows_returned) == 0:
            
            choice = session.choice_prompt(f"[X] No projects found. Continue with the current {session.project_id} [y/n]?")
            if choice.lower() == "y":
                project_id = session.project_id
            else:
                print("[X] Exiting since no projects were found. Run `enum_compute_projects` or `enum_resources` to find more.")
                return -1

        for project_data in rows_returned:
            project_name = project_data["name"]
            project_display_name = project_data["display_name"]
            project_id = project_data["project_id"]

            project_data["printout"] = f"{project_id} ({project_name} - \"{project_display_name}\")"

        rows_returned = sorted(rows_returned, key=lambda x: x["printout"])

        project_dict = session.choice_selector(rows_returned,"Choose an existing project from below to add SSH keys to:", fields=["printout"])
        if project_dict:
            project_id = project_dict["project_id"]

        else:
            print("Exiting...")
            return -1

    if not ssh_keys:

        selection = session.choice_selector(["STDIN","File"],"Supply SSH key via STDIN or via file (ex ~/.ssh/id_rsa.pub)?")

        if selection == "STDIN":
            ssh_key = session.choice_prompt("Enter SSH key here to add to the respective resource: ")
            ssh_keys = [ssh_key]

        elif selection == "File":

            ssh_file_path = session.choice_prompt("Enter SSH key here to add to the respective resource: ")

            ssh_keys = [line.strip() for line in open(ssh_file_path).readlines()]

    if not args.username:
            
        username = session.choice_prompt("What username is used for the SSH key: ")

    # Newline to handle multiple add ons
    added_metadata = [{
        "key":"ssh-keys"        
    }]

    for ssh_key in ssh_keys:
        ssh_keys_newline = "\n".join([username + ":" + line for line in ssh_keys])
        added_metadata[0]["value"] = ssh_keys_newline
    
    # Create client based off what we are trying to do (instance vs project)
    if change_instance:

        client = compute_v1.InstancesClient(credentials = session.credentials)  
        type_of_resource = "instance"

    elif change_project:

        client = compute_v1.ProjectsClient(credentials = session.credentials)    
        type_of_resource = "project"

    status = add_metadata(
            client,
            action_dict, 
            project_id, 
            added_metadata, 
            instance_name = instance_name, 
            instance_zone= instance_zone, 
            type_of_resource=type_of_resource,
            overwrite_previous_key_values = args.brute
        )

    if status:
        print(f"{UtilityTools.GREEN}[*] The SSH keys should have been added to the instance/project. You should be able to verify this with enum_instances or enum_compute_projects and querying appropriate tables with data tables <table_name>{UtilityTools.RESET}")
    

    else:
        print(f"{UtilityTools.RED}[X] There appears to have been an issue when uploading the SSH keys. They may have not been added.{UtilityTools.RESET}")

    if action_dict:
        session.insert_actions(action_dict, project_id, column_name = "compute_actions_allowed") 

