import argparse, os, ast, re
from datetime import datetime
from Modules.IAM.utils.util_helpers import *

def find_next_hop(session, current_member):
    next_hops = []

    # Get all roles that support implicit delegation or getAccessToken
    data = load_in_all_yaml_stuff()
    
    impersonation_roles = []
    for entry in data:
        if entry["permission"] == "iam.serviceAccounts.implicitDelegation":
            impersonation_roles.extend(entry.get("roles", []))
    
    get_access_token_roles = []
    for entry in data:
        if entry["permission"] == "iam.serviceAccounts.getAccessToken":
            get_access_token_roles.extend(entry.get("roles", []))

    role_categories = {
        "impersonation": impersonation_roles,
        "get_access_token": get_access_token_roles
    }

    def format_node(node):
        if node.startswith("projects/"):
            parts = node.split("/")
            project_id = parts[1]
            email = parts[-1]
            formatted_node = f"[{project_id}] - {email}"
            return {"name": node, "printout_name": formatted_node}
        return {"name": node, "printout_name": node}

    rows = session.get_data(
        "iam-bindings", 
        columns=["member", "project_id", "name", "display_name", "type", "roles"], 
        conditions=f"type = 'saaccounts' AND member = '{current_member}'"
    )

    for row in rows:
        member = row["member"]
        name = row["name"]
        roles = ast.literal_eval(row["roles"])
        
        has_access_token = any(role in role_categories["get_access_token"] for role in roles)
        has_impersonation = any(role in role_categories["impersonation"] for role in roles)
        
        formatted_node = format_node(name)

        if has_access_token:
            next_hops.append({"name": name, "printout_name": f"(ACCESS TOKEN) -> {formatted_node['printout_name']}"})
        
        if has_impersonation:
            next_hops.append({"name": "serviceAccount:" + name.split("/")[-1], "printout_name": f"(IMPERSONATE) -> {formatted_node['printout_name']}"})

    return next_hops

def find_routes(session, start_member, role_categories, final_member=None):
    routes = []
    visited = set()

    def format_node(node):
        if node.startswith("projects/"):
            parts = node.split("/")
            project_id = parts[1]
            email = parts[-1]
            formatted_node = f"[{project_id}] - {email}"
            return {"name": node, "printout_name": formatted_node}
        return {"name": node, "printout_name": node}

    def matches_final_member(node, final_member):
        if final_member in node:
            return True
        return False

    def recursive_find(current_member, path):
        if current_member in visited:
            return
        visited.add(current_member)

        rows = session.get_data(
            "iam-bindings", 
            columns=["member", "project_id", "name", "display_name", "type", "roles"], 
            conditions=f"type = 'saaccounts' AND member = '{current_member}'"
        )
        
        if not rows:
            # No further paths, end recursion if path is more than just the start member
            if len(path) > 1:
                if final_member is None or matches_final_member(path[-1]["name"], final_member):
                    routes.append(path)
            return
        
        for row in rows:
            member = row["member"]
            project_id = row["project_id"]
            name = row["name"]
            display_name = row["display_name"]
            type_of_resource = row["type"]
            roles = ast.literal_eval(row["roles"])
            
            has_access_token = any(role in role_categories["get_access_token"] for role in roles)
            has_impersonation = any(role in role_categories["impersonation"] for role in roles)
            
            formatted_node = format_node(name)
            
            if has_access_token:
                new_path = path + [{"name": name, "printout_name": f"(ACCESS TOKEN) -> {formatted_node['printout_name']}"}]
                if final_member is None or matches_final_member(name, final_member):
                    routes.append(new_path)
            
            if has_impersonation:
                next_step = {"name": name, "printout_name": f"(IMPERSONATE) -> {formatted_node['printout_name']}"}
                formatted_member = "serviceAccount:" + name.split("/")[-1]
                recursive_find(formatted_member, path + [next_step])
    
    recursive_find(start_member, [{"name": start_member, "printout_name": start_member}])
    return routes

def get_all_routes(session, final_member = None):

    # Get all roles that support implicit delegation or getAccessToken
    data = load_in_all_yaml_stuff()
    
    impersonation_roles = []
    for entry in data:
        if entry["permission"] == "iam.serviceAccounts.implicitDelegation":
            impersonation_roles.extend(entry.get("roles", []))
    
    get_access_token_roles = []
    for entry in data:
        if entry["permission"] == "iam.serviceAccounts.getAccessToken":
            get_access_token_roles.extend(entry.get("roles", []))

    role_categories = {
        "impersonation": impersonation_roles,
        "get_access_token": get_access_token_roles
    }
    
    bindings = session.get_bindings()
    all_unique_members = list(set(binding['member'] for binding in bindings if binding['member'].startswith("serviceAccount:")))
    
    # Get all members
    combined_routes = []

    # Get all routes and key-value matching for print
    for member in all_unique_members:

        all_routes = find_routes(session, member, role_categories, final_member = final_member)
        if all_routes:
            combined_routes.extend(all_routes)
        # Separate routes into categories
        access_token_routes = []
        impersonation_routes = []

        # Split up routes that end with ACCESS TOKEN VS IMPERSONATE
        for route in combined_routes:

            if route[-1]["printout_name"].startswith("(ACCESS TOKEN)"):
                # Adds route list which contains nodes
                access_token_routes.append({"route": route})
            
            elif route[-1]["printout_name"].startswith("(IMPERSONATE)"):
                 # Adds route list which contains nodes
                impersonation_routes.append({"route": route})

        # Sort routes by the number of nodes (shortest path first)
        access_token_routes.sort(key=lambda x: len(x["route"]))
        impersonation_routes.sort(key=lambda x: len(x["route"]))


    return access_token_routes, impersonation_routes

def create_delegation_chain(choice):
    
    delegation_chain = []
    for index, node in enumerate(choice["route"]):
        
        node_name = node["name"] 
        
        if index == len(choice["route"]) - 1:
            
            if node_name.startswith("serviceAccount:"):
                
                # Split by ":" and get the email part
                target_account = f"projects/-/serviceAccounts/{node_name.split(':')[1]}"
            
            elif "projects/" in node_name:
                parts = node_name.split('/')
                parts[1] = '-'
                target_account = '/'.join(parts)

        else:

            if node_name.startswith("serviceAccount:"):
                # Split by ":" and get the email part
                delegation_chain.append(f"projects/-/serviceAccounts/{node_name.split(':')[1]}")
            
            elif "projects/" in node_name:
                parts = node_name.split('/')
                parts[1] = '-'
                delegation_chain.append('/'.join(parts))

    return target_account, delegation_chain

def load_in_all_yaml_stuff():
    with open("./utils/permission-mapping.yaml") as file:
        yaml_content = file.read()
    data = yaml.safe_load(yaml_content)
    return data

# Entrypoint
def run_module(user_args, session, first_run = False, last_run = False, callback = False, output_format = ["table"]):

    # Set up Argparser to handle flag arguments
    parser = argparse.ArgumentParser(description="Enumerate Buckets Options", allow_abbrev=False)
    
    # Module specific arguments

    delegation_group_options = parser.add_mutually_exclusive_group()
    delegation_group_options.add_argument("--delegation", type=str, required=False,  help="Bucket name to get metadata for")
    delegation_group_options.add_argument("--delegation-target", type=str, required=False,  help="Bucket name to get metadata for")
    delegation_group_options.add_argument("--all-delegation", action="store_true", required=False,  help="Bucket name to get metadata for")
    
    delegation_group_options.add_argument("--target-sa", type=str, required=False,  help="Bucket name to get metadata for")

    # Debug/non-module specific
    parser.add_argument("-v","--debug",action="store_true",required=False,help="Get verbose data during the module run")
    
    args = parser.parse_args(user_args)
    debug = args.debug

    action_dict = {}

    iam_client = iam_credentials_v1.IAMCredentialsClient(credentials = session.credentials)
    
    delegation_step, delegation_dest, delegation_all, get_token_direct = False,False,False,False


    if not args.delegation and not args.delegation_target and not args.all_delegation and not args.target_sa:
        choice = session.choice_selector(["Delegation Step Through", "Delegation Destination", "All Deligation Options", "Get Access Token Directly"],"Do you want to step through delegation with a starting SA, find delegation routes ending with a specific SA, see ALL delegation SA options, or do no delegation and just get a access token for a SA directly?")

        if choice in ["Delegation Step Through"]:
            delegation_step = True
        elif choice in ["Delegation Destination"]:
            delegation_dest = True
        elif choice in ["All Deligation Options"]:
            delegation_all = True
        elif choice in ["Get Access Token Directly"]:
            get_token_direct = True
        elif choice == "Exit":
            return -1

    # All Delegation Options
    if args.all_delegation or delegation_all:
            
        access_token_routes, impersonation_routes = get_all_routes(session)

        if access_token_routes:

            # Create display names for the routes
            impersonation_options = []
            for route_path in access_token_routes:
                route_path["display_name"] = "\n    ".join(step["printout_name"] for step in route_path["route"])

            for route_path in impersonation_routes:
                impersonation_options.append("\n    ".join(step["printout_name"] for step in route_path["route"]))

            data = {
                    "title": "Review the routes below that allow one to get an access token.",
                    "data_values": access_token_routes
                }

            choice = session.choice_selector(
                access_token_routes, 
                f"Choose a path from below to attempt implicit delegation. Note this will only work on fields that give access tokens, but those with impersonation are also shown for your benefit", 
                footer_title = "Impersonation routes are provided below. Note these do not end in getting an access token but are still provided for your visiblity.",
                footer_list = impersonation_options,
                fields=["display_name"]
                )
            
            if choice == "Exit":
                return -1
            else:

                target_account, delegation_chain = create_delegation_chain(choice)

            

                access_token = iam_generate_access_token(
                    iam_client, 
                    target_account.strip(), 
                    delegation = delegation_chain, 
                    debug=debug
                    )
        else:
            print("[X] No delegation routes were identified. If the data has not been gathered yet considering running enum_service_accounts and enum_policy_bindings, or just run enum_all")
            access_token = None

    # Final node delegation route
    elif args.delegation_target or delegation_dest:


        if args.delegation_target:

            final_member = args.delegation_target

        else:

            final_member = session.choose_member(type_of_member = "service_accounts")
            if final_member:
                if debug:
                    print(f"[DEBUG] Proceeding with member: {member}")
            else:
                return -1    

        access_token_routes, impersonation_routes = get_all_routes(session, final_member = final_member)

        # Create display names for the routes
        
        if access_token_routes:
            for route_path in access_token_routes:
                route_path["display_name"] = "\n    ".join(step["printout_name"] for step in route_path["route"])

            impersonation_options = []
            for route_path in impersonation_routes:
                impersonation_options.append("\n    ".join(step["printout_name"] for step in route_path["route"]))

            data = {
                    "title": "Review the routes below that allow one to get an access token.",
                    "data_values": access_token_routes
                }

            choice = session.choice_selector(
                access_token_routes, 
                f"Choose a path from below to attempt implicit delegation. Note this will only work on fields that give access tokens, but those with impersonation are also shown for your benefit", 
                footer_title = "Impersonation routes are provided below. Note these do not end in getting an access token but are still provided for your visiblity.",
                footer_list = impersonation_options,
                fields=["display_name"]
                )
            
            if choice == "Exit":
                return -1
            else:

                target_account, delegation_chain = create_delegation_chain(choice)

                access_token = iam_generate_access_token(
                    iam_client, 
                    target_account.strip(), 
                    delegation = delegation_chain, 
                    debug=debug
                    )
        else:
            print("[X] No delegation routes were identified leading to the final SA. Consider running --all-delegation to see all potential options.")
            access_token = None

    # Just Acceess Token
    elif args.delegation or delegation_step:


        if args.delegation:

            starting_member = args.delegation

        else:

            starting_member = session.choose_member(type_of_member = "service_accounts")
            if starting_member:
                if debug:
                    print(f"[DEBUG] Proceeding with member: {member}")
            else:
                return -1    
            
        delegation_chain, target_account = [f"projects/-/serviceAccounts/{starting_member.split(':')[-1]}"], None

        # Use range to avoid infininte loop
        for i in range(1000):
            
            output_test = find_next_hop(session, starting_member)

            # If there is a next hop
            if output_test:

                access_token_routes, impersonation_routes = [], []

                for route in output_test:

                    if route["printout_name"].startswith("(ACCESS TOKEN)"):
                        # Adds route list which contains nodes
                        access_token_routes.append(route)
                    
                    elif route["printout_name"].startswith("(IMPERSONATE)"):
                        # Adds route list which contains nodes
                        impersonation_routes.append(route)

                data = [
                        {
                            "title": "If you want to end the delegation chain choose an access token path from below:",
                            "data_values": access_token_routes

                        },
                        {
                            "title": "If you want to continue the delegation chain choose from the path below:",
                            "data_values": impersonation_routes

                        }
                    ]

                string = f"Delegation Chain So Far: {delegation_chain}"

                choice = session.choice_selector(header = string, chunk_mappings = data,fields=["printout_name"])

                if choice == "Exit":
                    break
                
                else:
                    
                    node_printout_name = choice["printout_name"]
                    node_name = choice["name"]

                    # If they chose access token
                    if any(node_printout_name == route["printout_name"] for route in access_token_routes):
                        print("END")
                        if node_name.startswith("serviceAccount:"):
                            # Split by ":" and get the email part
                            target_account = f"projects/-/serviceAccounts/{node_name.split(':')[1]}"
                            break
                        
                        elif "projects/" in node_name:
                            parts = node_name.split('/')
                            parts[1] = '-'
                            target_account = '/'.join(parts)
                            break

                    # If they chose impersonation
                    elif any(node_printout_name == route["printout_name"] for route in impersonation_routes):
                        
                        if node_name.startswith("serviceAccount:"):
                            # Split by ":" and get the email part
                            delegation_chain.append(f"projects/-/serviceAccounts/{node_name.split(':')[1]}")
                            starting_member = node_name

                        elif "projects/" in node_name:
                            parts = node_name.split('/')
                            starting_member = f"serviceAccount:{node_name[-1]}"
                            
                            parts[1] = '-'
                            
                            delegation_chain.append('/'.join(parts))

            else:
                print(f"[X] There are no next nodes to traverse to. The current delegation chain before failing was:")
                for index, delegation in enumerate(delegation_chain):
                    print(f" {index+1}. {delegation}")
                break


        if target_account:
            access_token = iam_generate_access_token(
                iam_client, 
                target_account.strip(), 
                delegation = delegation_chain, 
                debug=debug
                )

    else:

        if args.target_sa:

            target_account  = args.target_sa

        else:
            
            rows_returned = session.get_data("iam-principals", columns = ["name", "email"], conditions = "type = \"service_account\"")
            if len(rows_returned) ==0:
                print("[X] No service accounts were identified in the existing databases. If you know of the email re-run the module with the --sa-email flag. Exiting...")
                return -1
            else:
                sa_dict = session.choice_selector(rows_returned,"Choose an existing SA from below to generate an acess token from:", fields=["email", "name"])
                target_account = sa_dict["email"]
                

        access_token = iam_generate_access_token(iam_client, target_account, debug=debug)
        
        if access_token:
            action_dict.setdefault(project_id, {}).setdefault("iam.serviceAccounts.getAccessToken", {}).setdefault("service account", set()).add(sa)

    if access_token:

        lifetime = access_token.expire_time
        token = access_token.access_token

        print(f"[*] Successful API Call. Access Token will last until {lifetime}:")
        print(f"[*] Token: {token}")

        choice = session.choice_prompt("Do you want to assume the new credentials? [y/n]")

        if choice.lower() == "y":
                
                email = target_account

                current_datetime = datetime.now()
                timestamp = current_datetime.strftime("%m%d%Y_%H%M_UTC")

                credname = email + "_" + timestamp
                access_token = token

                if "projects/-/serviceAccounts/" in credname:
                    credname = credname.replace("projects/-/serviceAccounts/","")
                if "projects/-/serviceAccounts/" in email:
                    email = email.replace("projects/-/serviceAccounts/","")

                session.add_oauth2_account(credname, token=access_token, project_id = session.project_id,  email = email, assume = True) 
    

